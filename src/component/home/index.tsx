// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import React, { useState, useEffect } from "react";
import fromUnixTime from "date-fns/fromUnixTime";
import {
  PlasmicHome,
  DefaultHomeProps,
} from "component/plasmic/home/PlasmicHome";
import { initialValueEmpty } from "component/editor/config/initialValues";
import { Search } from "@venturemark/numnum";
import { format } from "date-fns";
import { serialize } from "module/serialize";
import { get } from "module/store";
import { useEditor } from "component/editor/compose";
import { IUpdate } from "module/interface/update";
import { ITimeline } from "module/interface/timeline";
import { IMetric } from "module/interface/metric";
import * as api from "module/api";

const defaultTimeline: ITimeline = {
  name: "",
  timelineId: "",
  userId: "",
  dataKey: "",
  isCurrent: false,
  updates: [],
  data: [],
};

interface HomeProps extends DefaultHomeProps {}

export function Component(props: HomeProps) {
  const userId = window.location.pathname.slice(1);
  const [timelines, setTimelines] = useState<ITimeline[]>([]);
  const [currentTimeline, setCurrentTimeline] = useState<ITimeline>(
    defaultTimeline
  );

  const [refresh, setRefresh] = useState(false);

  const [updates, setUpdates] = useState<IUpdate[]>([]);
  const [metrics, setMetrics] = useState<IMetric[]>([]);

  const store = get("composeEditor.content") ?? "";
  const initialValue = store !== "" ? JSON.parse(store) : initialValueEmpty;
  const hasContentDefault =
    serialize(initialValue) === "" || serialize(initialValue) === undefined
      ? undefined
      : "hasContent";
  const defaultNumber = Search(serialize(initialValue)) ?? 0;
  const defaultProgress = serialize(initialValue).length;

  const { editorShape, setEditorShape } = useEditor({
    value: initialValue,
    hasContent: hasContentDefault,
    numberValue: defaultNumber[0],
    progress: defaultProgress,
  });

  useEffect(() => {
    const fetchData = async () => {
      let timelinesResponse: ITimeline[] = await api.API.Timeline.Search(
        "user.venturemark.co/id",
        userId
      );

      // put in default data if there are no existing timelines
      if (timelinesResponse.length < 1) {
        let firstResponse = api.API.Timeline.Create("User Feedback", userId);
        firstResponse.then((timelineId) => {
          api.API.MetricUpdate.Create(
            "One user said, 'I would rather shovel $#*!' that use your software. She gave us a satisfaction rating of 1 because she likes our idea.",
            1,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );

          api.API.MetricUpdate.Create(
            "We're struggling to get our satisfaction rating higher. We believe there is a disconnect between the value users expect and the marketing message. We're not delivering.",
            2,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "Most recent user satisfaction rating was 8.3! Why the uptick? High touch onboarding. Our customer support is crushing it. Narrower product focus leads to stronger believers",
            8.3,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
        });

        let secondResponse = api.API.Timeline.Create("Recurring Users", userId);
        secondResponse.then((timelineId) => {
          api.API.MetricUpdate.Create(
            "Thanks mom! 1 recurring user",
            1,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );

          api.API.MetricUpdate.Create(
            "I don't know who these 123 people that keep using our product are. Which is cool. but we've done a lot of marketing",
            123,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "We really only have 12 users that also make viable customers. The rest were consuming lots of resource but were neither contributing to the platform nor showed any desire to every pay.",
            12,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
        });

        let thirdResponse = api.API.Timeline.Create(
          "Recurring Revenue",
          userId
        );
        thirdResponse.then((timelineId) => {
          api.API.MetricUpdate.Create(
            "First customer signed at $40/month",
            40,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "we're at $160/month! 4 customers and signing a new customer each week.",
            160,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "We believe we were able to increase MRR to $1160 by introducing a new incentive program.",
            1160,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "Covid hit and brought our existing customers down to 120",
            120,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
        });

        let fourthResponse = api.API.Timeline.Create(
          "Feature Development",
          userId
        );
        fourthResponse.then((timelineId) => {
          api.API.MetricUpdate.Create(
            "We're currently releasing 1 features per week. And there is a lot of regression.",
            1,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );

          api.API.MetricUpdate.Create(
            "We're currently releasing 3 features per week. We also brought onboard a like-minded fellow to help build backend.",
            3,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          api.API.MetricUpdate.Create(
            "We now have a complete team. We're shipping 10 features per week.",
            10,
            "timeline.venturemark.co/id",
            timelineId,
            "user.venturemark.co/id",
            userId
          );
          setRefresh(true); // re-fetch from client after tasks
        });
      }

      if (timelinesResponse.length > 0) {
        let currentTimelineResponse: ITimeline = timelinesResponse[0];

        if (currentTimeline.timelineId) {
          currentTimelineResponse = currentTimeline;
        }
        currentTimelineResponse.isCurrent = true;

        setCurrentTimeline(currentTimelineResponse);

        const activeTimelines = timelinesResponse.map((timeline) => {
          if (timeline.timelineId === currentTimeline.timelineId) {
            return { ...timeline, isCurrent: true };
          }
          return timeline;
        });

        const metricsResponse: any = await api.API.Metric.Search(
          "timeline.venturemark.co/id",
          currentTimelineResponse.timelineId,
          "user.venturemark.co/id",
          currentTimelineResponse.userId
        );
        const updatesResponse: any = await api.API.Update.Search(
          "timeline.venturemark.co/id",
          currentTimelineResponse.timelineId,
          "user.venturemark.co/id",
          currentTimelineResponse.userId
        );

        console.log(
          "timeline, metrics, updates:",
          currentTimelineResponse,
          metricsResponse,
          updatesResponse
        );

        const mappedMetrics: IMetric[] = metricsResponse.map(
          (metric: IMetric) => {
            const timeStamp = fromUnixTime(
              Number(metric.updateId) / 1000000000
            );
            const date = format(timeStamp, "PP");
            console.log(date);
            return {
              ...metric,
              [currentTimelineResponse.name]: metric.value,
              date: date,
            };
          }
        );

        console.log("mappedMetrics", mappedMetrics);

        let concatAndDeDuplicateObjects = (p: any, ...arrs: any) =>
          []
            .concat(...arrs)
            .reduce(
              (a, b) =>
                !a.filter((c) => b[p] === c[p]).length ? [...a, b] : a,
              []
            );

        const deDuplicatedUpdates = concatAndDeDuplicateObjects(
          "updateId",
          updatesResponse,
          mappedMetrics
        );
        console.log("new updates", deDuplicatedUpdates);
        const sortedMetrics = mappedMetrics.sort(
          (a: IMetric, b: IMetric) => Number(a.updateId) - Number(b.updateId)
        );
        console.log("sorted metrics:", sortedMetrics);
        setTimelines(activeTimelines);
        setUpdates(deDuplicatedUpdates);
        setMetrics(sortedMetrics);

        if (refresh) {
          setRefresh(false);
        }
      }
    };

    userId && fetchData();
  }, [refresh, currentTimeline, userId]);

  return (
    <PlasmicHome
      sidebar={{
        timelines: timelines,
        setTimelines: setTimelines,
        refresh: refresh,
        setRefresh: setRefresh,
        setCurrentTimeline: setCurrentTimeline,
        userId: currentTimeline.userId || userId,
      }}
      actionBar={{
        errorMessage: editorShape.error,
        progress: editorShape.progress,
        editorShape: editorShape,
        setEditorShape: setEditorShape,
      }}
      // updatesContainer={{
      //   children: updates.map((update) => (
      //     <Update
      //       text={update.text}
      //       key={update.updateId}
      //       id={update.updateId}
      //       dataKey={currentTimeline.dataKey}
      //       data={metrics}
      //       name={currentTimeline.name}
      //       isFlipped={update.isFlipped}
      //       isContext={update.isContext}
      //       updates={updates}
      //       setUpdates={setUpdates}
      //     />
      //   )),
      // }}
    />
  );
}
